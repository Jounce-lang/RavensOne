/// Easing functions for animations

pub fn get_easing(name: &str) -> fn(f64) -> f64 {
    match name {
        "linear" => linear,
        "easeInQuad" => ease_in_quad,
        "easeOutQuad" => ease_out_quad,
        "easeInOutQuad" => ease_in_out_quad,
        "easeInCubic" => ease_in_cubic,
        "easeOutCubic" => ease_out_cubic,
        "easeInOutCubic" => ease_in_out_cubic,
        "easeInBack" => ease_in_back,
        "easeOutBack" => ease_out_back,
        "easeInOutBack" => ease_in_out_back,
        "easeInElastic" => ease_in_elastic,
        "easeOutElastic" => ease_out_elastic,
        "easeInBounce" => ease_in_bounce,
        "easeOutBounce" => ease_out_bounce,
        _ => linear
    }
}

pub fn linear(t: f64) -> f64 {
    t
}

pub fn ease_in_quad(t: f64) -> f64 {
    t * t
}

pub fn ease_out_quad(t: f64) -> f64 {
    t * (2.0 - t)
}

pub fn ease_in_out_quad(t: f64) -> f64 {
    if t < 0.5 {
        2.0 * t * t
    } else {
        -1.0 + (4.0 - 2.0 * t) * t
    }
}

pub fn ease_in_cubic(t: f64) -> f64 {
    t * t * t
}

pub fn ease_out_cubic(t: f64) -> f64 {
    let t1 = t - 1.0;
    t1 * t1 * t1 + 1.0
}

pub fn ease_in_out_cubic(t: f64) -> f64 {
    if t < 0.5 {
        4.0 * t * t * t
    } else {
        let t1 = 2.0 * t - 2.0;
        0.5 * t1 * t1 * t1 + 1.0
    }
}

pub fn ease_in_back(t: f64) -> f64 {
    let c1 = 1.70158;
    let c3 = c1 + 1.0;
    c3 * t * t * t - c1 * t * t
}

pub fn ease_out_back(t: f64) -> f64 {
    let c1 = 1.70158;
    let c3 = c1 + 1.0;
    let t1 = t - 1.0;
    1.0 + c3 * t1.powi(3) + c1 * t1.powi(2)
}

pub fn ease_in_out_back(t: f64) -> f64 {
    let c1 = 1.70158;
    let c2 = c1 * 1.525;

    if t < 0.5 {
        ((2.0 * t).powi(2) * ((c2 + 1.0) * 2.0 * t - c2)) / 2.0
    } else {
        ((2.0 * t - 2.0).powi(2) * ((c2 + 1.0) * (t * 2.0 - 2.0) + c2) + 2.0) / 2.0
    }
}

pub fn ease_in_elastic(t: f64) -> f64 {
    let c4 = (2.0 * PI) / 3.0;

    if t == 0.0 {
        0.0
    } else if t == 1.0 {
        1.0
    } else {
        -2.0f64.powf(10.0 * t - 10.0) * ((t * 10.0 - 10.75) * c4).sin()
    }
}

pub fn ease_out_elastic(t: f64) -> f64 {
    let c4 = (2.0 * PI) / 3.0;

    if t == 0.0 {
        0.0
    } else if t == 1.0 {
        1.0
    } else {
        2.0f64.powf(-10.0 * t) * ((t * 10.0 - 0.75) * c4).sin() + 1.0
    }
}

pub fn ease_out_bounce(t: f64) -> f64 {
    let n1 = 7.5625;
    let d1 = 2.75;

    if t < 1.0 / d1 {
        n1 * t * t
    } else if t < 2.0 / d1 {
        let t1 = t - 1.5 / d1;
        n1 * t1 * t1 + 0.75
    } else if t < 2.5 / d1 {
        let t1 = t - 2.25 / d1;
        n1 * t1 * t1 + 0.9375
    } else {
        let t1 = t - 2.625 / d1;
        n1 * t1 * t1 + 0.984375
    }
}

pub fn ease_in_bounce(t: f64) -> f64 {
    1.0 - ease_out_bounce(1.0 - t)
}
