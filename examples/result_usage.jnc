// Test Result<T, E> type usage
// Demonstrates the standard library Result type for error handling

// Error types for our examples
enum ParseError {
    InvalidFormat,
    OutOfRange,
    Empty,
}

enum DivisionError {
    DivideByZero,
}

enum FileError {
    NotFound,
    PermissionDenied,
    IOError,
}

// Function that can fail - parsing a number from a string
fn parse_number(s: string) -> Result<i32, ParseError> {
    if s == "" {
        return Result::Err(ParseError::Empty);
    } else if s == "42" {
        return Result::Ok(42);
    } else if s == "100" {
        return Result::Ok(100);
    } else {
        return Result::Err(ParseError::InvalidFormat);
    }
}

// Function that divides two numbers safely
fn safe_divide(numerator: i32, denominator: i32) -> Result<i32, DivisionError> {
    if denominator == 0 {
        return Result::Err(DivisionError::DivideByZero);
    } else {
        return Result::Ok(numerator / denominator);
    }
}

// Function that reads a file (simulated)
fn read_file(filename: string) -> Result<string, FileError> {
    if filename == "data.txt" {
        return Result::Ok("File contents here");
    } else if filename == "secret.txt" {
        return Result::Err(FileError::PermissionDenied);
    } else {
        return Result::Err(FileError::NotFound);
    }
}

// Function demonstrating Result methods
fn result_methods() -> i32 {
    // Create some results
    let ok_value = Result::Ok(42);
    let err_value = Result::Err(ParseError::InvalidFormat);

    // is_ok and is_err
    let is_success = ok_value.is_ok();  // true
    let is_failure = err_value.is_err();  // true

    // unwrap_or - provide a default value
    let result1 = ok_value.unwrap_or(0);  // Returns 42
    let result2 = err_value.unwrap_or(0);  // Returns 0

    // map - transform the Ok value
    let doubled = ok_value.map(|x| x * 2);  // Ok(84)
    let mapped_err = err_value.map(|x| x * 2);  // Err(InvalidFormat)

    // map_err - transform the Err value
    let remapped = err_value.map_err(|_| DivisionError::DivideByZero);

    // and_then - chain operations that can fail
    let chained = ok_value.and_then(|x| {
        if x > 40 {
            Result::Ok(x + 10)
        } else {
            Result::Err(ParseError::OutOfRange)
        }
    });

    // or - provide an alternative result
    let value1 = ok_value.or(Result::Ok(100));  // Ok(42)
    let value2 = err_value.or(Result::Ok(100));  // Ok(100)

    // Convert to Option
    let as_option = ok_value.ok();  // Some(42)
    let err_as_option = err_value.err();  // Some(InvalidFormat)

    return result1;
}

// Function demonstrating pattern matching with Result
fn pattern_match_result(res: Result<i32, ParseError>) -> i32 {
    match res {
        Result::Ok(value) => {
            return value * 2;
        },
        Result::Err(error) => {
            match error {
                ParseError::Empty => return 0,
                ParseError::InvalidFormat => return -1,
                ParseError::OutOfRange => return -2,
            }
        },
    }
}

// Function that chains multiple operations
fn chain_operations(input: string) -> Result<i32, ParseError> {
    // Parse the number
    let num = parse_number(input)?;  // Early return on error

    // Double it
    let doubled = num * 2;

    // Return success
    return Result::Ok(doubled);
}

// Function demonstrating error recovery
fn with_recovery(s: string) -> i32 {
    // Try to parse, recover with default on error
    let result = parse_number(s)
        .unwrap_or_else(|err| {
            match err {
                ParseError::Empty => 0,
                ParseError::InvalidFormat => -1,
                ParseError::OutOfRange => -2,
            }
        });

    return result;
}

// Function that combines multiple Results
fn combine_results(a: string, b: string) -> Result<i32, ParseError> {
    // Parse both numbers
    let num1 = parse_number(a)?;
    let num2 = parse_number(b)?;

    // Add them
    return Result::Ok(num1 + num2);
}

// Main function demonstrating various Result use cases
fn main() -> i32 {
    // Test parsing
    let parsed1 = parse_number("42");  // Ok(42)
    let parsed2 = parse_number("xyz");  // Err(InvalidFormat)
    let parsed3 = parse_number("");     // Err(Empty)

    // Test division
    let div1 = safe_divide(10, 2);  // Ok(5)
    let div2 = safe_divide(10, 0);  // Err(DivideByZero)

    // Test file reading
    let file1 = read_file("data.txt");    // Ok("File contents here")
    let file2 = read_file("missing.txt");  // Err(NotFound)

    // Use pattern matching
    let matched1 = pattern_match_result(Result::Ok(21));  // 42
    let matched2 = pattern_match_result(Result::Err(ParseError::Empty));  // 0

    // Use Result methods
    let method_result = result_methods();

    // Chain operations
    let chained = combine_results("42", "100");  // Ok(142)

    // Error recovery
    let recovered = with_recovery("invalid");  // -1

    // Transpose Result<Option<T>> to Option<Result<T>>
    let result_option = Result::Ok(Option::Some(42));
    let option_result = result_option.transpose();  // Some(Ok(42))

    // Return a value (unwrap with default)
    return div1.unwrap_or(0);
}
